import { Minecraft } from "../../basis.js";
import { YoniDimension, Dimension } from "../../dimension.js";
import { Location, Vector3, DimensionLikeValue } from "../../Location.js";
import { VolumeArea } from "./VolumeArea.js";
import { Chunk } from "./Chunk.js";

type VolumeCache = (undefined | string[])[];
interface VolumeOptions {
    asyncVolumeSystem?: boolean;
}
interface VolumeAreaOption {
    dimension: DimensionLikeValue;
    begin: Vector3;
    end: Vector3;
}

export class Volume {
    public static position2Location(position: number, area: VolumeArea): Location ={
        let { x, y, z } = area;
        let baseLocation = area.begin.clone();
        
        let nX = (position % x) >>> 0;
        let nY = (position / x % y) >>> 0;
        let nZ = (position / x / y % z) >>> 0;
        
        if (nZ > z){
            throw new RangeError("chunk position "+position+" out of volume size");
        }
        
        return baseLocation.add([nX, nY, nZ]);
    }
    public readonly size: number;
    public readonly asyncVolumeSystem: boolean;
    public readonly volumeArea: VolumeArea;
    public constructor(area: VolumeAreaOption, options?: VolumeOptions){
        let dimension = Dimension.dim(area.dimension);
        
        let bLoc = area.begin;
        let eLoc = area.end;
        
        let bX = Math.min(bLoc.x, eLoc.x);
        let bY = Math.min(bLoc.y, eLoc.y);
        let bZ = Math.min(bLoc.z, eLoc.z);
        
        let eX = Math.max(bLoc.x, eLoc.x);
        let eY = Math.max(bLoc.y, eLoc.y);
        let eZ = Math.max(bLoc.z, eLoc.z);
        
        let volumeArea = {
            dimension: dimension,
            begin: new Location(dimension, bX, bY, bZ),
            x: (eX - bX) + 1,
            y: (eY - bY) + 1,
            z: (eZ - bZ) + 1,
        };
        
        let size = volumeArea.x * volumeArea.y * volumeArea.z;
        
        this.volumeArea = volumeArea;
        this.size = size;
        this.caches = new Array(size);
        this.asyncVolumeSystem = options?.asyncVolumeSystem ?? false;
    }
    private caches: (undefined | VolumeCache)[];
    private setCache(position: number, index: number, strArr: string[]): void {
        if (!this.asyncVolumeSystem) return;
        
        if (position < 0 || Math.floor(position) !== position && position !== position){
            throw new TypeError("position not valid");
        }
        if (index < 0 || Math.floor(index) !== index && index !== index){
            throw new TypeError("index not valid");
        }
        
        if (!(position in this.caches)){
            this.caches[position] = [];
        }
        
        let vc = this.caches[position] as string[][];
        vc[index] = strArr;
    }
    private getCache(position: number, index: number): string[] | undefined {
        if (!this.asyncVolumeSystem) return undefined;

        let vc = this.caches[position];
        if (vc === undefined){
            return undefined;
        } else {
            return vc[index];
        }
    }
    public getStringArray(position: number, index: number): string[] {
        let cache = this.getCache(position, index);
        if (cache){
            return cache;
        }
        let result = Volume.position2Location(possition, this.volumeArea)
            .getBlock()
            .getComponent("inventory") as Minecraft.InventoryComponent
            .container
            .getItem(index)
            .getLore():
        
        cache = 
    }
    public setStringArray(position: number, index: number, strArr: string[]): void {
    }
    public getString(position: number, index: number): string {
    }
    public setString(position: number, index: number, str: string): void {
    }
    public getData(position: number, index: number, buffer?: ArrayBuffer): ArrayBuffer {
    }
    public setData(position: number, index: number, buffer: ArrayBuffer): void {
    }
    /*
    getChunk(position: number): Chunk{
        if (position in this.dataCachedChunks){
            return this.dataCachedChunks[position];
        }
        
        let location = Volume.position2Location(position, this.volumeArea);
        
        let chunk = new Chunk(this, position, location);
        
        return chunk;
    }
    flushChunks(forceProcess: boolean = false){
        if (!this.#asyncVolumeSystem && !forceProcess){
            return;
        }
        
        if (this.dataCachedChunks.length === 0){
            return;
        }
    }
    static position2Location(position: number, area: VolumeArea){
        let { x, y, z } = area;
        let baseLocation = area.begin.clone();
        
        let nX = (position % x) >>> 0;
        let nY = (position / x % y) >>> 0;
        let nZ = (position / x / y % z) >>> 0;
        
        if (nZ > z){
            throw new RangeError("chunk position "+position+" out of volume size");
        }
        
        return baseLocation.add([nX, nY, nZ]);
    }*/
}


// export class Chunk {
    // location: Readonly<Location>;
    // mblock: YoniBlock;
    // mcontainer: Minecraft.Container;
    // index: number;
    // volume: Volume;
    // get size(){
        // return this.mcontainer.size;
    // }
    // get asyncVolumeSystem(): boolean {
        // return this.volume.asyncVolumeSystem;
    // }
    // dataCaches: string[];
    // constructor(volume: Volume, index: number, location: Location){
        // this.volume = volume;
        // this.index = index;
        // this.location = Location.makeReadonly(location);
        // this.mblock = this.location.getBlock();
        // let inventory = this.mblock.getComponent("minecraft:inventory") as Minecraft.BlockInventoryComponent;
        // if (inventory == null)
            // throw new Error("chunk mblock inventory not found");
        // this.mcontainer = inventory.container;
        // this.dataCaches = new Array<string>(this.size);
    // }
    // /**
     // * 获取代表此区块上指定的块对象。
     // * @param {string} dataStr - 要存储在此块上的数据字符串。
     // */
    // getBlock(index: number): ChunkBlock {
        // if (index < 0
        // || index >= this.size
        // || Math.floor(index) !== index)
            // throw new RangeError("no block at the index "+index);
        
        // let block = new ChunkBlock(this, index);
        
        // return block;
    // }
    // /**
     // * 将字符串写入到指定的的块。
     // * @param {string} dataStr - 要存储在此块上的数据字符串。
     // */
    // setDataStr(index: number, dataStr: string, noCache: boolean = false): void {
        // if (this.asyncVolumeSystem && !noCache){
            // this.volume.dataCachedChunks[this.index] = this;
            // this.dataCaches[index] = dataStr;
        // } else {
            // let mitem = new Minecraft.ItemStack("minecraft:stone");
            // mitem.setLore(dataStr.split("\u0000"));
            // this.mcontainer.setItem(index, mitem);
        // }
    // }
    // /**
     // * 读取块上存入的字符串。
     // * @returns {string} 此块上存储的数据字符串。
     // */
    // getDataStr(index: number, noCache: boolean = false): string {
        // if (this.asyncVolumeSystem && !noCache && (index in this.dataCaches)){
            // return this.dataCaches[index];
        // }
        
        // let mitem = this.mcontainer.getItem(index);
        
        // let dataStr = "";
        // if (mitem != null){
            // dataStr = mitem.getLore().join("\u0000");
        // }
        
        // if (this.asyncVolumeSystem && !noCache){
            // this.volume.dataCachedChunks[this.index] = this;
            // this.dataCaches[index] = dataStr;
        // }
        // return dataStr;
    // }
    
    // /**
     // * 将数据写入到指定的的块。
     // * @param {ArrayBuffer} buffer - 要存储在此块上的数据。
     // */
    // setData(index: number, buffer: ArrayBuffer): void {
        // let view = new Uint8Array(buffer);
        // let dataStr = Array.prototype.map.call(view, b => String.fromCodePoint(b)).join("");
        // this.setDataStr(index, dataStr);
    // }
    
    // /**
     // * 读取块上的数据。
     // * @param {ArrayBuffer} [buffer] - 若指定，将此块上的数据写入此缓冲区。
     // * @returns {ArrayBuffer} 此块上存储的数据。
     // */
    // getData(index: number, buffer?: ArrayBuffer): ArrayBuffer {
        // //读取数据字符串
        // let dataStr = this.getDataStr(index);
        
        // //将字符串转换为一串数字
        // let data: number[] = dataStr.split("")
            // .map((c: string) => (c.codePointAt(0) as number) % 256);
        
        // //若指定，将数据截断为缓冲区的长度，否则创建新的缓冲区
        // if (buffer instanceof ArrayBuffer){
            // if (buffer.byteLength < data.length){
                // data.length = buffer.byteLength;
            // }
        // } else {
            // buffer = new ArrayBuffer(data.length);
        // }
        
        // //通过视图向缓冲区写入数据
        // let view = new Uint8Array(buffer);
        
        // data.forEach((byte, index) => {
            // view[index] = byte;
        // });
        
        // return buffer;
    // }
    // getStringArray(block: number): string[] {
        // return this.getDataStr(block).split("\u0000");
    // }
    // setStringArray(block: number, arr: string[]): void {
        // if (arr.filter(v => v.indexOf("\u0000") !== -1).length !== 0){
            // throw new RangeError("char '\\u0000' is not allowed");
        // }
        // this.setDataStr(block, arr.join("\u0000"));
    // }
    // * entries(): Generator<[number, string]> {
        // for (let index = 0; index < this.size; index++){
            // yield [index, this.getDataStr(index)];
        // }
    // }
// }
