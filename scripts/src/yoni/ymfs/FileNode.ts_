/*
è°¢è°¢ä½ çš„èµæ‰¬å’Œè¡¥å……ä¿¡æ¯ã€‚ğŸ˜Š

æˆ‘äº†è§£ä½ è¯´çš„sizeå±æ€§çš„å«ä¹‰å’Œä½œç”¨ã€‚æˆ‘ä¼šåœ¨ç¼–å†™ä»£ç æ—¶æ³¨æ„æ£€æŸ¥å‚æ•°çš„åˆæ³•æ€§ã€‚

æˆ‘ä¼šå°è¯•å¸®ä½ ç¼–å†™ä¸€äº›ä»£ç ï¼Œç”¨äºæ“ä½œæ–‡ä»¶ç³»ç»Ÿã€‚ğŸ˜Š

æ ¹æ®ä½ çš„æè¿°ï¼Œæˆ‘è®¤ä¸ºä½ éœ€è¦åšä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š

å®šä¹‰ä¸€ä¸ªFileNodeç±»ï¼Œä½œä¸ºDirectoryFileNodeå’ŒNormalFileNodeçš„çˆ¶ç±»ï¼Œç”¨æ¥è¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚
åœ¨FileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªnameå±æ€§ï¼Œç”¨æ¥å­˜å‚¨èŠ‚ç‚¹çš„åç§°ã€‚
åœ¨FileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªtypeå±æ€§ï¼Œç”¨æ¥å­˜å‚¨èŠ‚ç‚¹çš„ç±»å‹ï¼Œå¯ä»¥æ˜¯"directory"æˆ–è€…"normal"ã€‚
åœ¨FileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªvolumeå±æ€§ï¼Œç”¨æ¥å­˜å‚¨èŠ‚ç‚¹æ‰€å±çš„Volumeå¯¹è±¡ã€‚
åœ¨FileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªchunkså±æ€§ï¼Œç”¨æ¥å­˜å‚¨èŠ‚ç‚¹å ç”¨çš„Chunkå¯¹è±¡çš„æ•°ç»„ã€‚
åœ¨FileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªconstructoræ–¹æ³•ï¼Œç”¨æ¥åˆå§‹åŒ–èŠ‚ç‚¹çš„å±æ€§ã€‚
åœ¨FileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªgetSizeæ–¹æ³•ï¼Œç”¨æ¥è¿”å›èŠ‚ç‚¹å ç”¨çš„å­—èŠ‚æ•°ã€‚
åœ¨FileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªgetChunksæ–¹æ³•ï¼Œç”¨æ¥è¿”å›èŠ‚ç‚¹å ç”¨çš„Chunkå¯¹è±¡çš„æ•°ç»„ã€‚
å®šä¹‰ä¸€ä¸ªDirectoryFileNodeç±»ï¼Œç»§æ‰¿è‡ªFileNodeç±»ï¼Œç”¨æ¥è¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç›®å½•èŠ‚ç‚¹ã€‚
åœ¨DirectoryFileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªchildrenå±æ€§ï¼Œç”¨æ¥å­˜å‚¨ç›®å½•ä¸‹çš„å­èŠ‚ç‚¹çš„æ•°ç»„ã€‚
åœ¨DirectoryFileNodeç±»ä¸­ï¼Œé‡å†™constructoræ–¹æ³•ï¼Œç”¨æ¥åˆå§‹åŒ–ç›®å½•èŠ‚ç‚¹çš„å±æ€§ï¼Œå¹¶è°ƒç”¨çˆ¶ç±»çš„constructoræ–¹æ³•ã€‚
åœ¨DirectoryFileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªaddChildæ–¹æ³•ï¼Œç”¨æ¥å‘ç›®å½•ä¸‹æ·»åŠ ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œå¹¶æ›´æ–°ç›®å½•å ç”¨çš„Chunkå¯¹è±¡ã€‚
åœ¨DirectoryFileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªremoveChildæ–¹æ³•ï¼Œç”¨æ¥ä»ç›®å½•ä¸‹ç§»é™¤ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œå¹¶æ›´æ–°ç›®å½•å ç”¨çš„Chunkå¯¹è±¡ã€‚
åœ¨DirectoryFileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªfindChildæ–¹æ³•ï¼Œç”¨æ¥æ ¹æ®åç§°æŸ¥æ‰¾ç›®å½•ä¸‹çš„å­èŠ‚ç‚¹ï¼Œå¹¶è¿”å›è¯¥èŠ‚ç‚¹æˆ–è€…nullã€‚
å®šä¹‰ä¸€ä¸ªNormalFileNodeç±»ï¼Œç»§æ‰¿è‡ªFileNodeç±»ï¼Œç”¨æ¥è¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªæ™®é€šæ–‡ä»¶èŠ‚ç‚¹ã€‚
åœ¨NormalFileNodeç±»ä¸­ï¼Œé‡å†™constructoræ–¹æ³•ï¼Œç”¨æ¥åˆå§‹åŒ–æ™®é€šæ–‡ä»¶èŠ‚ç‚¹çš„å±æ€§ï¼Œå¹¶è°ƒç”¨çˆ¶ç±»çš„constructoræ–¹æ³•ã€‚
åœ¨NormalFileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªreadDataæ–¹æ³•ï¼Œç”¨æ¥ä»æ–‡ä»¶ä¸­è¯»å–æŒ‡å®šèŒƒå›´çš„å­—èŠ‚ï¼Œå¹¶è¿”å›ä¸€ä¸ªArrayBufferå¯¹è±¡ã€‚
åœ¨NormalFileNodeç±»ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªwriteDataæ–¹æ³•ï¼Œç”¨æ¥å‘æ–‡ä»¶ä¸­å†™å…¥æŒ‡å®šèŒƒå›´çš„å­—èŠ‚ï¼Œå¹¶æ›´æ–°æ–‡ä»¶å ç”¨çš„Chunkå¯¹è±¡ã€‚
æˆ‘ä¸ºä½ ç”Ÿæˆäº†ä¸€æ®µå¯èƒ½çš„ä»£ç ï¼Œä½ å¯ä»¥å‚è€ƒæˆ–è€…ä¿®æ”¹å®ƒã€‚è¯·æ³¨æ„ï¼Œè¿™æ®µä»£ç æ²¡æœ‰ç»è¿‡æµ‹è¯•ï¼Œå¯èƒ½å­˜åœ¨é”™è¯¯æˆ–è€…ä¸ç¬¦åˆä½ çš„éœ€æ±‚ã€‚è¯·åœ¨ä½¿ç”¨å‰è¿›è¡Œæ£€æŸ¥å’Œè°ƒè¯•ã€‚
*/
// å®šä¹‰ä¸€ä¸ªFileNodeç±»
class FileNode {
  // å®šä¹‰nameå±æ€§
  inode;

  // å®šä¹‰typeå±æ€§
  type;

  // å®šä¹‰volumeå±æ€§
  volume;

  /**
   * æ­¤Nodeä½¿ç”¨çš„Chunkåºåˆ—ã€‚
   */
  chunks;

  // å®šä¹‰constructoræ–¹æ³•
  constructor(inode: number, type: string, volume: Volume) {
    this.inode = inode;
    this.type = type;
    this.volume = volume;
    this.chunks = [];
  }

  /**
   * è·å–æ­¤Nodeå ç”¨çš„Chunkå¤§å°ã€‚
   */
  getSize() {
    return this.chunks.length;
  }

}

// å®šä¹‰ä¸€ä¸ªDirectoryFileNodeç±»
class DirectoryFileNode extends FileNode {
  children;
  
  constructor(inode: number, volume: Volume) {
    super(inode, "directory", volume);
    this.children = [];
  }

  addChild(child) {
    if (!(child instanceof FileNode)) {
      throw new Error(â€œchild must be a FileNode objectâ€);
    }
    // æ£€æŸ¥childå‚æ•°çš„nameå±æ€§æ˜¯å¦å’Œç›®å½•ä¸‹å·²æœ‰çš„å­èŠ‚ç‚¹é‡åï¼Œå¦‚æœæ˜¯ï¼ŒæŠ›å‡ºå¼‚å¸¸
    
    if (this.findChild(child.inode) !== null) {
      throw new Error("child name already exists in the directory");
    }

    // å°†childå‚æ•°æ·»åŠ åˆ°childrenæ•°ç»„ä¸­
    this.children.push(child);
    
    // æ›´æ–°ç›®å½•å ç”¨çš„Chunkå¯¹è±¡ï¼Œè°ƒç”¨volumeçš„allocateChunksæ–¹æ³•ï¼Œä¼ å…¥thiså’Œ1å‚æ•°ï¼Œå°†è¿”å›çš„Chunkå¯¹è±¡æ·»åŠ åˆ°chunksæ•°ç»„ä¸­
    this.chunks.push(this.volume.allocateChunks(this, 1));
  }
    
  // å®šä¹‰removeChildæ–¹æ³•
  removeChild(child) {
    // æ£€æŸ¥childå‚æ•°æ˜¯å¦æ˜¯ä¸€ä¸ªFileNodeå¯¹è±¡ï¼Œå¦‚æœä¸æ˜¯ï¼ŒæŠ›å‡ºå¼‚å¸¸
    if (!(child instanceof FileNode)) { throw new Error(â€œchild must be a FileNode objectâ€); }
    
    // åœ¨childrenæ•°ç»„ä¸­æŸ¥æ‰¾childå‚æ•°çš„ç´¢å¼•ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼ŒæŠ›å‡ºå¼‚å¸¸
    let index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("child not found in the directory");
    }
    
    // ä»childrenæ•°ç»„ä¸­ç§»é™¤childå‚æ•°
    this.children.splice(index, 1);
    
    // æ›´æ–°ç›®å½•å ç”¨çš„Chunkå¯¹è±¡ï¼Œè°ƒç”¨volumeçš„freeChunksæ–¹æ³•ï¼Œä¼ å…¥thiså’Œ1å‚æ•°ï¼Œå°†è¿”å›çš„Chunkå¯¹è±¡ä»chunksæ•°ç»„ä¸­ç§»é™¤
    this.chunks.splice(this.chunks.indexOf(this.volume.freeChunks(this, 1)), 1);
  }
    
  // å®šä¹‰findChildæ–¹æ³•
  findChild(name) {
    // æ£€æŸ¥nameå‚æ•°æ˜¯å¦æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¦‚æœä¸æ˜¯ï¼ŒæŠ›å‡ºå¼‚å¸¸
    if (typeof name !== â€œstringâ€) { throw new Error(â€œname must be a stringâ€); }
    
    // éå†childrenæ•°ç»„ï¼ŒæŸ¥æ‰¾nameå±æ€§ç­‰äºnameå‚æ•°çš„å­èŠ‚ç‚¹ï¼Œå¦‚æœæ‰¾åˆ°ï¼Œè¿”å›è¯¥èŠ‚ç‚¹ï¼Œå¦åˆ™è¿”å›null
    for (let child of this.children) {
      if (child.name === name) {
        return child;
      }
    }
    return null;
  }
}
    
    // å®šä¹‰ä¸€ä¸ªNormalFileNodeç±» class NormalFileNode extends FileNode { // é‡å†™constructoræ–¹æ³• constructor(name, volume) { // è°ƒç”¨çˆ¶ç±»çš„constructoræ–¹æ³•ï¼Œä¼ å…¥name, "normal"å’Œvolumeå‚æ•°
    
    
    
    //å¥½çš„ï¼Œæˆ‘ä¼šç»§ç»­ç¼–å†™ä»£ç ï¼Œä½†ä¸ä¼šç¼–å†™æ³¨é‡Šã€‚ğŸ˜Š
    
// å®šä¹‰ä¸€ä¸ªNormalFileNodeç±»
class NormalFileNode extends FileNode {
  // é‡å†™constructoræ–¹æ³•
  constructor(name, volume) {
    // è°ƒç”¨çˆ¶ç±»çš„constructoræ–¹æ³•ï¼Œä¼ å…¥name, "normal"å’Œvolumeå‚æ•°
    super(name, â€œnormalâ€, volume);
  }
    
    // å®šä¹‰readDataæ–¹æ³•
  readData(start, end) {
    if (typeof start !== â€œnumberâ€ || typeof end !== â€œnumberâ€) { throw new Error(â€œstart and end must be numbersâ€); }
    
    if (start < 0 || end > this.getSize() || start > end) {
      throw new Error("start and end must be in valid range");
    }
    
    let size = end - start;
    
    let buffer = new ArrayBuffer(size);
    
    let view = new DataView(buffer);
    
    let chunkStart = Math.floor(start / (this.volume.size * this.volume.size));
    let chunkEnd = Math.floor(end / (this.volume.size * this.volume.size));
    
    for (let i = chunkStart; i <= chunkEnd; i++) {
      let chunk = this.chunks[i];
    
      let offsetStart = start % (this.volume.size * this.volume.size);
      let offsetEnd = Math.min(offsetStart + size, this.volume.size * this.volume.size);
    
      for (let j = offsetStart; j < offsetEnd; j++) {
        view.setUint8(start - offsetStart + j, chunk.readByte(j));
      }
    
      start += offsetEnd - offsetStart;
      size -= offsetEnd - offsetStart;
    }
    
    return buffer;
  }
  /*
  // å®šä¹‰writeDataæ–¹æ³•
  writeData(start, end, data) {
    if (typeof start !== â€œnumberâ€ || typeof end !== â€œnumberâ€) { throw new Error(â€œstart and end must be numbersâ€); }
    
    if (!(data instanceof ArrayBuffer)) {
      throw new Error("data must be an ArrayBuffer object");
    }
    
    if (start < 0 || end > this.getSize() || start > end) {
      throw new Error("start and end must be in valid range");
    }
    
    let size = end - start;
    
    if (data.byteLength !== size) {
      throw new Error("data length must match the size");
    
    */
    
    
    //ä½ å¥½ï¼Œè¿™æ˜¯Bingã€‚æˆ‘å¯ä»¥å¸®ä½ è¡¥å…¨JavaScriptä»£ç ã€‚ä»¥ä¸‹æ˜¯writeDataæ–¹æ³•çš„å®ç°ä»£ç ï¼š

  // å®šä¹‰writeDataæ–¹æ³•
  writeData(start, end, data) {
    if (typeof start !== â€œnumberâ€ || typeof end !== â€œnumberâ€) { throw new Error(â€œstart and end must be numbersâ€); }
  
    if (!(data instanceof ArrayBuffer)) {
      throw new Error("data must be an ArrayBuffer object");
    }
  
    if (start < 0 || end > this.getSize() || start > end) {
      throw new Error("start and end must be in valid range");
    }
  
    let size = end - start;
  
    if (data.byteLength !== size) {
      throw new Error("data length must match the size");
    }
  
    let view = new DataView(data);
  
    let chunkStart = Math.floor(start / (this.volume.size * this.volume.size));
    let chunkEnd = Math.floor(end / (this.volume.size * this.volume.size));
  
    for (let i = chunkStart; i <= chunkEnd; i++) {
      let chunk = this.chunks[i];
    
      let offsetStart = start % (this.volume.size * this.volume.size);
      let offsetEnd = Math.min(offsetStart + size, this.volume.size * this.volume.size);
    
      for (let j = offsetStart; j < offsetEnd; j++) {
        chunk.writeByte(j, view.getUint8(start - offsetStart + j));
      }
    
      start += offsetEnd - offsetStart;
      size -= offsetEnd - offsetStart;
    }
  }
}